Description: undisclosed security fix for CVE-2018-7033
Author: Tim Wickberg <tim@schedmd.com>
Last-Update: 2018-03-09

diff --git a/src/common/pack.c b/src/common/pack.c
index 88fa4ca421..fdc16a9300 100644
--- a/src/common/pack.c
+++ b/src/common/pack.c
@@ -54,6 +54,7 @@
 #include "src/common/pack.h"
 #include "src/common/xmalloc.h"
 #include "src/common/xassert.h"
+#include "src/slurmdbd/read_config.h"
 
 /*
  * Define slurm-specific aliases for use by plugins, see slurm_xlator.h
@@ -87,6 +88,8 @@ strong_alias(unpackmem,		slurm_unpackmem);
 strong_alias(unpackmem_ptr,	slurm_unpackmem_ptr);
 strong_alias(unpackmem_xmalloc,	slurm_unpackmem_xmalloc);
 strong_alias(unpackmem_malloc,	slurm_unpackmem_malloc);
+strong_alias(unpackstr_xmalloc_escaped, slurm_unpackstr_xmalloc_escaped);
+strong_alias(unpackstr_xmalloc_chooser, slurm_unpackstr_xmalloc_chooser);
 strong_alias(packstr_array,	slurm_packstr_array);
 strong_alias(unpackstr_array,	slurm_unpackstr_array);
 strong_alias(packmem_array,	slurm_packmem_array);
@@ -828,6 +831,79 @@ int unpackmem_malloc(char **valp, uint32_t * size_valp, Buf buffer)
 }
 
 /*
+ * Given a buffer containing a network byte order 16-bit integer,
+ * and an arbitrary char string, copy the data string into the location
+ * specified by valp and escape ' and \ to be database safe.
+ * Also return the sizes of 'valp' in bytes.
+ * Adjust buffer counters.
+ * NOTE: valp is set to point into a newly created buffer,
+ *	the caller is responsible for calling xfree() on *valp
+ *	if non-NULL (set to NULL on zero size buffer value)
+ * NOTE: size_valp may not match how much data was processed from buffer, but
+ *       will match the length of the returned 'valp'.
+ * WARNING: These escapes are sufficient to protect MariaDB/MySQL, but
+ *          may not be sufficient if databases are added in the future.
+ */
+int unpackstr_xmalloc_escaped(char **valp, uint32_t *size_valp, Buf buffer)
+{
+	uint32_t ns;
+
+	if (remaining_buf(buffer) < sizeof(ns))
+		return SLURM_ERROR;
+
+	memcpy(&ns, &buffer->head[buffer->processed], sizeof(ns));
+	*size_valp = ntohl(ns);
+	buffer->processed += sizeof(ns);
+
+	if (*size_valp > MAX_PACK_MEM_LEN) {
+		error("%s: Buffer to be unpacked is too large (%u > %u)",
+		      __func__, *size_valp, MAX_PACK_MEM_LEN);
+		return SLURM_ERROR;
+	} else if (*size_valp > 0) {
+		uint32_t cnt = *size_valp;
+
+		if (remaining_buf(buffer) < cnt)
+			return SLURM_ERROR;
+
+		/* make a buffer 2 times the size just to be safe */
+		*valp = xmalloc_nz((cnt * 2) + 1);
+		if (*valp) {
+			char *copy = NULL, *str, tmp;
+			uint32_t i;
+			copy = *valp;
+			str = &buffer->head[buffer->processed];
+
+			for (i = 0; i < cnt && *str; i++) {
+				tmp = *str++;
+				if ((tmp == '\\') || (tmp == '\'')) {
+					*copy++ = '\\';
+					(*size_valp)++;
+				}
+
+				*copy++ = tmp;
+			}
+
+			/* Since we used xmalloc_nz, terminate the string. */
+			*copy++ = '\0';
+		}
+
+		/* add the original value since that is what we processed */
+		buffer->processed += cnt;
+	} else
+		*valp = NULL;
+	return SLURM_SUCCESS;
+}
+
+int unpackstr_xmalloc_chooser(char **valp, uint32_t *size_valp, Buf buf)
+{
+	if (slurmdbd_conf)
+		return unpackstr_xmalloc_escaped(valp, size_valp, buf);
+	else
+		return unpackmem_xmalloc(valp, size_valp, buf);
+}
+
+
+/*
  * Given a pointer to array of char * (char ** or char *[] ) and a size
  * (size_val), convert size_val to network byte order and store in the
  * buffer followed by the data at valp. Adjust buffer counters.
diff --git a/src/common/pack.h b/src/common/pack.h
index aba5de41cb..176882a9ce 100644
--- a/src/common/pack.h
+++ b/src/common/pack.h
@@ -126,6 +126,9 @@ int	unpackmem_ptr(char **valp, uint32_t *size_valp, Buf buffer);
 int	unpackmem_xmalloc(char **valp, uint32_t *size_valp, Buf buffer);
 int	unpackmem_malloc(char **valp, uint32_t *size_valp, Buf buffer);
 
+int	unpackstr_xmalloc_escaped(char **valp, uint32_t *size_valp, Buf buffer);
+int	unpackstr_xmalloc_chooser(char **valp, uint32_t *size_valp, Buf buffer);
+
 void	packstr_array(char **valp, uint32_t size_val, Buf buffer);
 int	unpackstr_array(char ***valp, uint32_t* size_val, Buf buffer);
 
@@ -334,8 +337,12 @@ int	unpackmem_array(char *valp, uint32_t size_valp, Buf buffer);
 #define safe_unpackstr_malloc	                        \
         safe_unpackmem_malloc
 
-#define safe_unpackstr_xmalloc	                        \
-        safe_unpackmem_xmalloc
+#define safe_unpackstr_xmalloc(valp, size_valp, buf) do {	\
+	assert(sizeof(*size_valp) == sizeof(uint32_t));        	\
+	assert(buf->magic == BUF_MAGIC);		        \
+	if (unpackstr_xmalloc_chooser(valp, size_valp, buf))    \
+		goto unpack_error;		       		\
+} while (0)
 
 #define safe_unpackstr_array(valp,size_valp,buf) do {	\
 	assert(sizeof(*size_valp) == sizeof(uint32_t)); \
diff --git a/src/common/slurm_xlator.h b/src/common/slurm_xlator.h
index 30b15ca8c0..c3d10b867b 100644
--- a/src/common/slurm_xlator.h
+++ b/src/common/slurm_xlator.h
@@ -259,6 +259,8 @@
 #define	unpackmem_ptr		slurm_unpackmem_ptr
 #define	unpackmem_xmalloc	slurm_unpackmem_xmalloc
 #define	unpackmem_malloc	slurm_unpackmem_malloc
+#define	unpackstr_xmalloc_escaped slurm_unpackstr_xmalloc_escaped
+#define	unpackstr_xmalloc_chooser slurm_unpackstr_xmalloc_chooser
 #define	packstr_array		slurm_packstr_array
 #define	unpackstr_array		slurm_unpackstr_array
 #define	packmem_array		slurm_packmem_array
diff --git a/src/plugins/accounting_storage/mysql/as_mysql_cluster.c b/src/plugins/accounting_storage/mysql/as_mysql_cluster.c
index 9e9db7f817..213bac10f8 100644
--- a/src/plugins/accounting_storage/mysql/as_mysql_cluster.c
+++ b/src/plugins/accounting_storage/mysql/as_mysql_cluster.c
@@ -1382,9 +1382,9 @@ extern int as_mysql_node_down(mysql_conn_t *mysql_conn,
 		return SLURM_ERROR;
 
 	if (reason)
-		my_reason = slurm_add_slash_to_quotes(reason);
+		my_reason = reason;
 	else
-		my_reason = slurm_add_slash_to_quotes(node_ptr->reason);
+		my_reason = node_ptr->reason;
 
 	row = mysql_fetch_row(result);
 	if (row && (node_ptr->node_state == slurm_atoul(row[0])) &&
@@ -1396,7 +1396,6 @@ extern int as_mysql_node_down(mysql_conn_t *mysql_conn,
 				 node_ptr->name, mysql_conn->cluster_name,
 				 node_ptr->node_state, row[0],
 				 my_reason, row[1]);
-		xfree(my_reason);
 		mysql_free_result(result);
 		return SLURM_SUCCESS;
 	}
@@ -1434,7 +1433,7 @@ extern int as_mysql_node_down(mysql_conn_t *mysql_conn,
 		DB_DEBUG(mysql_conn->conn, "query\n%s", query);
 	rc = mysql_db_query(mysql_conn, query);
 	xfree(query);
-	xfree(my_reason);
+
 	return rc;
 }
 
diff --git a/src/plugins/accounting_storage/mysql/as_mysql_job.c b/src/plugins/accounting_storage/mysql/as_mysql_job.c
index dfbc95c360..29ee81a1b0 100644
--- a/src/plugins/accounting_storage/mysql/as_mysql_job.c
+++ b/src/plugins/accounting_storage/mysql/as_mysql_job.c
@@ -307,7 +307,6 @@ extern int as_mysql_job_start(mysql_conn_t *mysql_conn,
 	char *nodes = NULL, *jname = NULL, *node_inx = NULL;
 	int track_steps = 0;
 	char *block_id = NULL, *partition = NULL;
-	char *gres_req = NULL, *gres_alloc = NULL, *mcs_label = NULL;
 	char temp_bit[BUF_SIZE];
 	char *query = NULL;
 	int reinit = 0;
@@ -466,9 +465,9 @@ extern int as_mysql_job_start(mysql_conn_t *mysql_conn,
 no_rollup_change:
 
 	if (job_ptr->name && job_ptr->name[0])
-		jname = slurm_add_slash_to_quotes(job_ptr->name);
+		jname = job_ptr->name;
 	else {
-		jname = xstrdup("allocation");
+		jname = "allocation";
 		track_steps = 1;
 	}
 
@@ -509,17 +508,9 @@ no_rollup_change:
 				       job_ptr->assoc_id);
 
 	if (!IS_JOB_PENDING(job_ptr) && job_ptr->part_ptr)
-		partition = slurm_add_slash_to_quotes(job_ptr->part_ptr->name);
+		partition = job_ptr->part_ptr->name;
 	else if (job_ptr->partition)
-		partition = slurm_add_slash_to_quotes(job_ptr->partition);
-
-	if (job_ptr->gres_req)
-		gres_req = slurm_add_slash_to_quotes(job_ptr->gres_req);
-
-	if (job_ptr->gres_alloc)
-		gres_alloc = slurm_add_slash_to_quotes(job_ptr->gres_alloc);
-	if (job_ptr->mcs_label)
-		mcs_label = slurm_add_slash_to_quotes(job_ptr->mcs_label);
+		partition = job_ptr->partition;
 
 	if (!job_ptr->db_index) {
 		if (start_time && (job_state >= JOB_COMPLETE) &&
@@ -565,9 +556,9 @@ no_rollup_change:
 			xstrcat(query, ", wckey");
 		if (node_inx)
 			xstrcat(query, ", node_inx");
-		if (gres_req)
+		if (job_ptr->gres_req)
 			xstrcat(query, ", gres_req");
-		if (gres_alloc)
+		if (job_ptr->gres_alloc)
 			xstrcat(query, ", gres_alloc");
 		if (array_recs && array_recs->task_id_str)
 			xstrcat(query, ", array_task_str, array_max_tasks, "
@@ -601,8 +592,8 @@ no_rollup_change:
 
 		if (wckeyid)
 			xstrfmtcat(query, ", %u", wckeyid);
-		if (mcs_label)
-			xstrfmtcat(query, ", '%s'", mcs_label);
+		if (job_ptr->mcs_label)
+			xstrfmtcat(query, ", '%s'", job_ptr->mcs_label);
 		if (job_ptr->account)
 			xstrfmtcat(query, ", '%s'", job_ptr->account);
 		if (partition)
@@ -613,10 +604,10 @@ no_rollup_change:
 			xstrfmtcat(query, ", '%s'", job_ptr->wckey);
 		if (node_inx)
 			xstrfmtcat(query, ", '%s'", node_inx);
-		if (gres_req)
-			xstrfmtcat(query, ", '%s'", gres_req);
-		if (gres_alloc)
-			xstrfmtcat(query, ", '%s'", gres_alloc);
+		if (job_ptr->gres_req)
+			xstrfmtcat(query, ", '%s'", job_ptr->gres_req);
+		if (job_ptr->gres_alloc)
+			xstrfmtcat(query, ", '%s'", job_ptr->gres_alloc);
 		if (array_recs && array_recs->task_id_str)
 			xstrfmtcat(query, ", '%s', %u, %u",
 				   array_recs->task_id_str,
@@ -632,7 +623,8 @@ no_rollup_change:
 		if (job_ptr->tres_req_str)
 			xstrfmtcat(query, ", '%s'", job_ptr->tres_req_str);
 		if (job_ptr->details->work_dir)
-			xstrfmtcat(query, ", '%s'", job_ptr->details->work_dir);
+			xstrfmtcat(query, ", '%s'",
+				   job_ptr->details->work_dir);
 
 		xstrfmtcat(query,
 			   ") on duplicate key update "
@@ -660,7 +652,8 @@ no_rollup_change:
 		if (wckeyid)
 			xstrfmtcat(query, ", id_wckey=%u", wckeyid);
 		if (job_ptr->mcs_label)
-			xstrfmtcat(query, ", mcs_label='%s'", mcs_label);
+			xstrfmtcat(query, ", mcs_label='%s'",
+				   job_ptr->mcs_label);
 		if (job_ptr->account)
 			xstrfmtcat(query, ", account='%s'", job_ptr->account);
 		if (partition)
@@ -671,10 +664,11 @@ no_rollup_change:
 			xstrfmtcat(query, ", wckey='%s'", job_ptr->wckey);
 		if (node_inx)
 			xstrfmtcat(query, ", node_inx='%s'", node_inx);
-		if (gres_req)
-			xstrfmtcat(query, ", gres_req='%s'", gres_req);
-		if (gres_alloc)
-			xstrfmtcat(query, ", gres_alloc='%s'", gres_alloc);
+		if (job_ptr->gres_req)
+			xstrfmtcat(query, ", gres_req='%s'", job_ptr->gres_req);
+		if (job_ptr->gres_alloc)
+			xstrfmtcat(query, ", gres_alloc='%s'",
+				   job_ptr->gres_alloc);
 		if (array_recs && array_recs->task_id_str)
 			xstrfmtcat(query, ", array_task_str='%s', "
 				   "array_max_tasks=%u, array_task_pending=%u",
@@ -720,7 +714,8 @@ no_rollup_change:
 		if (wckeyid)
 			xstrfmtcat(query, "id_wckey=%u, ", wckeyid);
 		if (job_ptr->mcs_label)
-			xstrfmtcat(query, "mcs_label='%s', ", mcs_label);
+			xstrfmtcat(query, "mcs_label='%s', ",
+				   job_ptr->mcs_label);
 		if (job_ptr->account)
 			xstrfmtcat(query, "account='%s', ", job_ptr->account);
 		if (partition)
@@ -731,10 +726,12 @@ no_rollup_change:
 			xstrfmtcat(query, "wckey='%s', ", job_ptr->wckey);
 		if (node_inx)
 			xstrfmtcat(query, "node_inx='%s', ", node_inx);
-		if (gres_req)
-			xstrfmtcat(query, "gres_req='%s', ", gres_req);
-		if (gres_alloc)
-			xstrfmtcat(query, "gres_alloc='%s', ", gres_alloc);
+		if (job_ptr->gres_req)
+			xstrfmtcat(query, "gres_req='%s', ",
+				   job_ptr->gres_req);
+		if (job_ptr->gres_alloc)
+			xstrfmtcat(query, "gres_alloc='%s', ",
+				   job_ptr->gres_alloc);
 		if (array_recs && array_recs->task_id_str)
 			xstrfmtcat(query, "array_task_str='%s', "
 				   "array_max_tasks=%u, "
@@ -789,12 +786,7 @@ no_rollup_change:
 end_it:
 	xfree(tres_alloc_str);
 	xfree(block_id);
-	xfree(partition);
-	xfree(gres_req);
-	xfree(gres_alloc);
-	xfree(jname);
 	xfree(query);
-	xfree(mcs_label);
 
 	return rc;
 }
@@ -829,11 +821,9 @@ extern List as_mysql_modify_job(mysql_conn_t *mysql_conn, uint32_t uid,
 	if (job->derived_ec != NO_VAL)
 		xstrfmtcat(vals, ", derived_ec=%u", job->derived_ec);
 
-	if (job->derived_es) {
-		char *derived_es = slurm_add_slash_to_quotes(job->derived_es);
-		xstrfmtcat(vals, ", derived_es='%s'", derived_es);
-		xfree(derived_es);
-	}
+	if (job->derived_es)
+		xstrfmtcat(vals, ", derived_es='%s'", job->derived_es);
+
 	if (!vals) {
 		errno = SLURM_NO_CHANGE_IN_DATA;
 		error("No change specified for job modification");
@@ -1037,18 +1027,12 @@ extern int as_mysql_job_complete(mysql_conn_t *mysql_conn,
 	else if (job_ptr->tres_alloc_str)
 		xstrfmtcat(query, ", tres_alloc='%s'", job_ptr->tres_alloc_str);
 
-	if (job_ptr->comment) {
-		char *comment = slurm_add_slash_to_quotes(job_ptr->comment);
-		xstrfmtcat(query, ", derived_es='%s'", comment);
-		xfree(comment);
-	}
+	if (job_ptr->comment)
+		xstrfmtcat(query, ", derived_es='%s'", job_ptr->comment);
 
-	if (job_ptr->admin_comment) {
-		char *comment = slurm_add_slash_to_quotes(
-			job_ptr->admin_comment);
-		xstrfmtcat(query, ", admin_comment='%s'", comment);
-		xfree(comment);
-	}
+	if (job_ptr->admin_comment)
+		xstrfmtcat(query, ", admin_comment='%s'",
+			   job_ptr->admin_comment);
 
 	exit_code = job_ptr->exit_code;
 	if (exit_code == 1) {
@@ -1079,7 +1063,7 @@ extern int as_mysql_step_start(mysql_conn_t *mysql_conn,
 	int rc = SLURM_SUCCESS;
 	char temp_bit[BUF_SIZE];
 	char node_list[BUFFER_SIZE];
-	char *node_inx = NULL, *step_name = NULL;
+	char *node_inx = NULL;
 	time_t start_time, submit_time;
 	char *query = NULL;
 
@@ -1198,8 +1182,6 @@ extern int as_mysql_step_start(mysql_conn_t *mysql_conn,
 		}
 	}
 
-	step_name = slurm_add_slash_to_quotes(step_ptr->name);
-
 	/* we want to print a -1 for the requid so leave it a
 	   %d */
 	/* The stepid could be -2 so use %d not %u */
@@ -1218,7 +1200,7 @@ extern int as_mysql_step_start(mysql_conn_t *mysql_conn,
 		mysql_conn->cluster_name, step_table,
 		step_ptr->job_ptr->db_index,
 		step_ptr->step_id,
-		(int)start_time, step_name,
+		(int)start_time, step_ptr->name,
 		JOB_RUNNING, step_ptr->tres_alloc_str,
 		nodes, tasks, node_list, node_inx, task_dist,
 		step_ptr->cpu_freq_max, step_ptr->cpu_freq_min,
@@ -1230,7 +1212,6 @@ extern int as_mysql_step_start(mysql_conn_t *mysql_conn,
 		DB_DEBUG(mysql_conn->conn, "query\n%s", query);
 	rc = mysql_db_query(mysql_conn, query);
 	xfree(query);
-	xfree(step_name);
 
 	return rc;
 }
diff --git a/src/plugins/accounting_storage/mysql/as_mysql_resv.c b/src/plugins/accounting_storage/mysql/as_mysql_resv.c
index 86cde4929d..0322be4603 100644
--- a/src/plugins/accounting_storage/mysql/as_mysql_resv.c
+++ b/src/plugins/accounting_storage/mysql/as_mysql_resv.c
@@ -98,11 +98,9 @@ static int _setup_resv_limits(slurmdb_reservation_rec_t *resv,
 	}
 
 	if (resv->name) {
-		char *tmp_char = slurm_add_slash_to_quotes(resv->name);
 		xstrcat(*cols, ", resv_name");
-		xstrfmtcat(*vals, ", '%s'", tmp_char);
-		xstrfmtcat(*extra, ", resv_name='%s'", tmp_char);
-		xfree(tmp_char);
+		xstrfmtcat(*vals, ", '%s'", resv->name);
+		xstrfmtcat(*extra, ", resv_name='%s'", resv->name);
 	}
 
 	if (resv->nodes) {
